***빠른 범용화 가이드 (제안)

프로파일 외부화

config/search-profiles.json에 설비/분야별 키워드·가중치·제외어·규정/교육 쿼리를 선언.

코드에서는 profile = resolveProfile(equipmentInfo, workType) 후 프로파일 기반으로만 쿼리/스코어 구성.

도메인 추론 → 태그화

equipmentInfo에서 이름 문자열 매칭 대신, 사전 정의된 **태그(예: 'electrical', 'hydraulic', 'rotating', 'pressure', 'confined-space')**를 생성하고 그 태그로 프로파일 선택.

스코어링 일반화

getEquipmentKeywords → getProfileWeights(profile)로 교체.

공통 축: (설비 태그 일치), (작업유형 일치), (위험유형 일치), (법령/교육 매칭) + *(벡터 점수)*를 동일한 수식으로 결합.

전기 기본값 제거

work_type 기본값 "전기작업" 삭제 → 입력 없으면 "일반작업" 등 중립값.

기본 위험 키워드는 공통(예: 추락, 협착, 낙하, 화재, 폭발, 유해화학물질)로 전환.

필터의 부정 키워드 재설계

'외국인','캄보디아' 같은 내용 기반 배제는 데이터 특이점일 수 있음 → 카테고리/메타데이터(자료유형, 산업군, 법령/교육 여부) 중심의 필터로 전환.


***아래는 프로파일 JSON 스키마, 샘플 프로파일 JSON, 그리고 기존 ai-service.ts의 전기/GIS 하드코딩을 대체할 범용 쿼리 빌더/스코어러 TypeScript 모듈입니다.

profiles.schema.json — 프로파일 설정 파일의 스키마

profiles.sample.json — 전기(GIS) 포함 범용 예시 프로파일

profiles.ts — 프로파일 로딩, 프로파일 해석, 범용 쿼리 빌드, 하이브리드 스코어링 구현

integration-snippet.ts — 기존 코드에 최소 변경으로 붙이는 예시


1) profiles.schema.json


  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "SearchProfilesConfig",
  "type": "object",
  "properties": {
    "version": { "type": "string" },
    "profiles": {
      "type": "array",
      "items": { "$ref": "#/definitions/Profile" }
    }
  },
  "required": ["profiles"],
  "definitions": {
    "Match": {
      "type": "object",
      "properties": {
        "equipment_name_regex": { "type": "string" },
        "tags_any": { "type": "array", "items": { "type": "string" } },
        "work_types_any": { "type": "array", "items": { "type": "string" } },
        "risk_tags_any": { "type": "array", "items": { "type": "string" } }
      }
    },
    "Weights": {
      "type": "object",
      "properties": {
        "vector": { "type": "number", "minimum": 0 },
        "keyword": { "type": "number", "minimum": 0 },
        "equipment": { "type": "number", "minimum": 0 },
        "work_type": { "type": "number", "minimum": 0 },
        "risk": { "type": "number", "minimum": 0 },
        "regulation_hit": { "type": "number", "minimum": 0 },
        "education_hit": { "type": "number", "minimum": 0 }
      },
      "required": ["vector", "keyword", "equipment", "work_type", "risk", "regulation_hit", "education_hit"]
    },
    "Queries": {
      "type": "object",
      "properties": {
        "accidents": { "type": "array", "items": { "type": "string" } },
        "regulation": { "type": "array", "items": { "type": "string" } },
        "education": { "type": "array", "items": { "type": "string" } }
      }
    },
    "Profile": {
      "type": "object",
      "properties": {
        "id": { "type": "string" },
        "description": { "type": "string" },
        "match": { "$ref": "#/definitions/Match" },
        "keywords": { "type": "array", "items": { "type": "string" } },
        "exclude_keywords": { "type": "array", "items": { "type": "string" } },
        "include_if_any_keywords": { "type": "array", "items": { "type": "string" } },
        "exclude_if_any_keywords": { "type": "array", "items": { "type": "string" } },
        "queries": { "$ref": "#/definitions/Queries" },
        "weights": { "$ref": "#/definitions/Weights" }
      },
      "required": ["id", "weights"]
    }
  }


2) profiles.sample.json

필요에 맞게 복수 프로파일을 선언하세요. 첫 번째로 매칭되는 프로파일이 적용됩니다. 마지막에 항상 default를 둬서 폴백을 보장합니다.

{
  "version": "1.0",
  "profiles": [
    {
      "id": "electrical-hv-gis",
      "description": "전기 · 특별고압 · GIS/SF6/변전 설비",
      "match": {
        "equipment_name_regex": "(?i)(170\s*kV|gis|sf6|변전|가스절연)",
        "tags_any": ["electrical", "substation", "gis"]
      },
      "keywords": [
        "GIS", "SF6", "가스절연", "변전소", "개폐기", "고전압", "특별고압",
        "절연", "충전부", "감전", "절연장갑", "활선"
      ],
      "exclude_keywords": ["용접", "방열", "외국인 교육 일반", "캄보디아"],
      "include_if_any_keywords": ["전기", "고압", "절연", "변전", "GIS", "170kV"],
      "exclude_if_any_keywords": ["식품", "농업", "관광"],
      "queries": {
        "accidents": [
          "변전소 감전 사고", "개폐기 조작 감전", "특별고압 접촉 사고"
        ],
        "regulation": [
          "전기설비 안전거리", "절연용 보호구 착용", "정전 및 접지 절차", "활선 작업 금지"
        ],
        "education": [
          "고압 전기 안전교육", "GIS 운영 교육", "SF6 취급 안전"
        ]
      },
      "weights": {
        "vector": 0.55,
        "keyword": 0.15,
        "equipment": 0.10,
        "work_type": 0.08,
        "risk": 0.07,
        "regulation_hit": 0.03,
        "education_hit": 0.02
      }
    },

    {
      "id": "mechanical-rotating",
      "description": "기계 · 회전체/축계/베어링",
      "match": { "tags_any": ["mechanical", "rotating"] },
      "keywords": [
        "회전체", "커플링", "축정렬", "베어링", "윤활", "진동", "정비"
      ],
      "exclude_keywords": ["전기", "배전"],
      "queries": {
        "accidents": ["회전체 끼임 사고", "정비 중 협착"],
        "regulation": ["회전체 위험 방호", "가동부 방호덮개"],
        "education": ["베어링 윤활 교육", "축정렬 실습"]
      },
      "weights": {
        "vector": 0.55,
        "keyword": 0.18,
        "equipment": 0.10,
        "work_type": 0.07,
        "risk": 0.07,
        "regulation_hit": 0.02,
        "education_hit": 0.01
      }
    },

    {
      "id": "hydraulic-pressure",
      "description": "유압/가압 · 압력용기/배관/밸브",
      "match": { "tags_any": ["hydraulic", "pressure"] },
      "keywords": ["유압", "압력", "배관", "밸브", "누설", "압력용기", "파열"],
      "queries": {
        "accidents": ["배관 파열 사고", "유압 누설 화상"],
        "regulation": ["압력용기 안전밸브", "배관 안전기준"],
        "education": ["유압 시스템 안전", "밸브 취급 안전"]
      },
      "weights": {
        "vector": 0.55,
        "keyword": 0.17,
        "equipment": 0.10,
        "work_type": 0.08,
        "risk": 0.07,
        "regulation_hit": 0.02,
        "education_hit": 0.01
      }
    },

    {
      "id": "default",
      "description": "폴백: 분야 중립",
      "keywords": ["안전", "점검", "정비", "위험성 평가"],
      "queries": {
        "accidents": ["중량물 낙하 사고", "추락 사고"],
        "regulation": ["개인보호구", "작업허가서"],
        "education": ["작업 전 위험예지", "기본 안전수칙"]
      },
      "weights": {
        "vector": 0.60,
        "keyword": 0.15,
        "equipment": 0.10,
        "work_type": 0.07,
        "risk": 0.05,
        "regulation_hit": 0.02,
        "education_hit": 0.01
      }
    }
  ]
}

3) profiles.ts

기존 ai-service.ts에서 전기/GIS 하드코딩을 제거하고, 아래 유틸을 임포트해 동일 시그니처로 교체하십시오.

// profiles.ts
// 범용 프로파일 기반 쿼리 빌더 & 하이브리드 스코어러

export type WorkType = { id?: string; name: string };
export type EquipmentInfo = {
  id?: string;
  name: string;            // 예: "170kV GIS", "유압펌프"
  tags?: string[];         // 예: ["electrical", "substation", "gis"]
  riskTags?: string[];     // 예: ["감전", "고소", "압력"]
  metadata?: Record<string, any>;
};

export type SearchItem = {
  id: string;
  title?: string;
  text?: string;           // 본문
  metadata?: {
    sourceType?: "regulation" | "education" | "accident" | string;
    work_type?: string;
    equipment?: string;
    risk_keywords?: string;  // comma-separated 가능
    [k: string]: any;
  };
  vectorScore?: number;    // 0..1 (임베딩 유사도 점수)
};

// ------------------ Profiles ------------------

export interface ProfileMatch {
  equipment_name_regex?: string;   // JS RegExp 문자열
  tags_any?: string[];
  work_types_any?: string[];
  risk_tags_any?: string[];
}

export interface ProfileWeights {
  vector: number;
  keyword: number;
  equipment: number;
  work_type: number;
  risk: number;
  regulation_hit: number;
  education_hit: number;
}

export interface ProfileQueries {
  accidents?: string[];
  regulation?: string[];
  education?: string[];
}

export interface Profile {
  id: string;
  description?: string;
  match?: ProfileMatch;
  keywords?: string[];
  exclude_keywords?: string[];
  include_if_any_keywords?: string[];
  exclude_if_any_keywords?: string[];
  queries?: ProfileQueries;
  weights: ProfileWeights;
}

export interface SearchProfilesConfig {
  version?: string;
  profiles: Profile[];
}

// ------------------ Loader & Resolver ------------------

export function loadProfiles(json: SearchProfilesConfig): Profile[] {
  if (!json?.profiles?.length) throw new Error("profiles empty");
  return json.profiles;
}

export function resolveProfile(
  profiles: Profile[],
  equipment: EquipmentInfo,
  workType?: WorkType
): Profile {
  const name = equipment?.name ?? "";
  const tags = new Set((equipment?.tags ?? []).map((t) => t.toLowerCase()));
  const work = (workType?.name ?? "").toLowerCase();
  const riskTags = new Set((equipment?.riskTags ?? []).map((t) => t.toLowerCase()));

  for (const p of profiles) {
    const m = p.match;
    if (!m) continue;

    const nameOk = m.equipment_name_regex
      ? new RegExp(m.equipment_name_regex).test(name)
      : true;

    const tagsOk = m.tags_any?.length
      ? m.tags_any.some((t) => tags.has(t.toLowerCase()))
      : true;

    const workOk = m.work_types_any?.length
      ? m.work_types_any.some((w) => work.includes(w.toLowerCase()))
      : true;

    const riskOk = m.risk_tags_any?.length
      ? m.risk_tags_any.some((r) => riskTags.has(r.toLowerCase()))
      : true;

    if (nameOk && tagsOk && workOk && riskOk) return p;
  }

  // fallback: id === 'default' or 첫 프로파일
  return profiles.find((p) => p.id === "default") ?? profiles[0];
}

// ------------------ Query Builder ------------------

export interface BuiltQueries {
  accidents: string[];
  regulation: string[];
  education: string[];
  all: string[]; // dedup한 전체 쿼리
}

function uniq(arr: string[]): string[] {
  return Array.from(new Set(arr.filter(Boolean).map((s) => s.trim())));
}

function tokenize(str = ""): string[] {
  return str
    .split(/[\s·,|/\\]+/)
    .map((s) => s.trim())
    .filter(Boolean);
}

export function buildTargetedSearchQuery(
  profile: Profile,
  equipment: EquipmentInfo,
  workType?: WorkType
): BuiltQueries {
  const nameTokens = tokenize(equipment?.name);
  const wtTokens = tokenize(workType?.name);
  const eqTags = (equipment?.tags ?? []).map((t) => t.toLowerCase());
  const risk = (equipment?.riskTags ?? []).map((t) => t.toLowerCase());

  const baseKeywords = profile.keywords ?? [];
  const includeAny = profile.include_if_any_keywords ?? [];

  const dynamicHead = [
    [...nameTokens, ...eqTags].join(" ").trim(),
    wtTokens.join(" ").trim(),
    risk.join(" ").trim()
  ].filter(Boolean);

  // 규정/교육/사고 쿼리 구성: 프로파일 기본 + 동적 키워드 접합
  const accidents = uniq([
    ...((profile.queries?.accidents ?? []).map((q) => `${q}`)),
    ...(dynamicHead.length ? [dynamicHead.join(" ")] : [])
  ]);

  const regulation = uniq([
    ...((profile.queries?.regulation ?? []).map((q) => `${q}`)),
    ...(includeAny.length ? [includeAny.join(" ")] : [])
  ]);

  const education = uniq([
    ...((profile.queries?.education ?? []).map((q) => `${q}`)),
    ...(nameTokens.length ? [nameTokens.join(" ") + " 교육"] : [])
  ]);

  const all = uniq([...accidents, ...regulation, ...education]);
  return { accidents, regulation, education, all };
}

// ------------------ Hybrid Scoring ------------------

export interface HybridScoreOptions {
  textFields?: (keyof SearchItem)[]; // 기본: ['title', 'text']
  penaltyForExcluded?: number;       // 기본: -0.3
  bonusForIncludedAny?: number;      // 기본: +0.1
}

const DEFAULT_OPTS: Required<HybridScoreOptions> = {
  textFields: ["title", "text"],
  penaltyForExcluded: -0.3,
  bonusForIncludedAny: 0.1
};

function containsAny(hay: string, needles: string[]): number {
  const s = hay.toLowerCase();
  let hits = 0;
  for (const n of needles) {
    if (!n) continue;
    if (s.includes(n.toLowerCase())) hits += 1;
  }
  return hits;
}

function normalize(x: number, max = 10): number { // 0..1
  if (max <= 0) return 0;
  return Math.max(0, Math.min(1, x / max));
}

export function applyHybridScoring(
  item: SearchItem,
  profile: Profile,
  equipment: EquipmentInfo,
  workType?: WorkType,
  opts: HybridScoreOptions = {}
): number {
  const o = { ...DEFAULT_OPTS, ...opts };
  const text = [o.textFields]
    .flat()
    .map((f) => (item[f] as string) ?? "")
    .join("\n");

  const eqTokens = tokenize(equipment?.name).concat((equipment?.tags ?? []));
  const wtTokens = tokenize(workType?.name);
  const riskTokens = (equipment?.riskTags ?? []);

  const vec = Math.max(0, Math.min(1, item.vectorScore ?? 0));

  // 키워드/토큰 매칭 카운트
  const kwHits = containsAny(text, profile.keywords ?? []);
  const eqHits = containsAny(text, eqTokens);
  const wtHits = containsAny(text, wtTokens);
  const riskHits = containsAny(text, riskTokens);

  // include/exclude 조건
  const includeAny = profile.include_if_any_keywords ?? [];
  const exclude = profile.exclude_keywords ?? [];
  const exclAny = profile.exclude_if_any_keywords ?? [];

  let bonus = 0;
  if (includeAny.length && containsAny(text, includeAny) > 0) bonus += o.bonusForIncludedAny;
  let penalty = 0;
  if (exclude.length && containsAny(text, exclude) > 0) penalty += Math.abs(o.penaltyForExcluded);
  if (exclAny.length && containsAny(text, exclAny) > 0) penalty += Math.abs(o.penaltyForExcluded);

  // 출처 타입 보너스
  const st = item.metadata?.sourceType;
  const regHit = st === "regulation" ? 1 : 0;
  const eduHit = st === "education" ? 1 : 0;

  // 정규화된 부분 점수
  const s_kw = normalize(kwHits, 8);
  const s_eq = normalize(eqHits, 6);
  const s_wt = normalize(wtHits, 4);
  const s_rk = normalize(riskHits, 4);

  const w = profile.weights;

  let score = 0;
  score += w.vector * vec;
  score += w.keyword * s_kw;
  score += w.equipment * s_eq;
  score += w.work_type * s_wt;
  score += w.risk * s_rk;
  score += w.regulation_hit * regHit;
  score += w.education_hit * eduHit;

  score += bonus;
  score -= penalty;

  // 0..1 클램핑 (가독성)
  return Math.max(0, Math.min(1, score));
}

// ------------------ Filtering Utilities ------------------

export interface Filtered<T> { kept: T[]; dropped: T[]; }

export function filterByProfile<T extends SearchItem>(
  items: T[],
  profile: Profile
): Filtered<T> {
  const ex = profile.exclude_keywords ?? [];
  const exAny = profile.exclude_if_any_keywords ?? [];
  const kept: T[] = [];
  const dropped: T[] = [];
  for (const it of items) {
    const hay = `${it.title ?? ""}\n${it.text ?? ""}`.toLowerCase();
    const hitEx = ex.some((k) => hay.includes(k.toLowerCase()));
    const hitExAny = exAny.some((k) => hay.includes(k.toLowerCase()));
    if (hitEx || hitExAny) dropped.push(it); else kept.push(it);
  }
  return { kept, dropped };
}

// ------------------ Convenience (End-to-End) ------------------

export interface BuildAndScoreResult<T extends SearchItem> {
  queries: BuiltQueries;
  profile: Profile;
  scored: Array<{ item: T; score: number }>; // score desc
  dropped: T[];
}

export function buildAndScore<T extends SearchItem>(
  config: SearchProfilesConfig,
  equipment: EquipmentInfo,
  workType: WorkType | undefined,
  candidates: T[]
): BuildAndScoreResult<T> {
  const profiles = loadProfiles(config);
  const profile = resolveProfile(profiles, equipment, workType);
  const queries = buildTargetedSearchQuery(profile, equipment, workType);

  const { kept, dropped } = filterByProfile(candidates, profile);
  const scored = kept
    .map((it) => ({ item: it, score: applyHybridScoring(it, profile, equipment, workType) }))
    .sort((a, b) => b.score - a.score);

  return { queries, profile, scored, dropped };
}


4) integration-snippet.ts

기존 ai-service.ts에서 buildTargetedSearchQuery와 applyHybridScoring 호출부를 다음으로 교체하면, 전기/GIS에 종속된 분기를 프로파일 파일로 완전히 외부화할 수 있습니다.

// integration-snippet.ts
import type { EquipmentInfo, WorkType, SearchItem } from "./profiles";
import { buildAndScore } from "./profiles";
import profilesConfig from "./profiles.sample.json"; // 번들에 포함하거나 fs 로드

async function runHybridSearch(
  equipmentInfo: EquipmentInfo,
  workType: WorkType | undefined,
  initialCandidates: SearchItem[],
) {
  // 1) 프로파일 매칭 + 쿼리 빌드
  const { profile, queries } = buildAndScore(profilesConfig, equipmentInfo, workType, []);

  // 2) 벡터DB/키워드 검색 수행 (예시)
  const moreCandidates: SearchItem[] = await keywordAndVectorSearch(queries.all);

  // 3) 스코어링 (초기 후보 + 추가 후보 통합)
  const allCandidates = dedupById([...initialCandidates, ...moreCandidates]);
  const result = buildAndScore(profilesConfig, equipmentInfo, workType, allCandidates);

  // result.scored: 점수 내림차순 정렬됨
  return result;
}

function dedupById<T extends { id: string }>(arr: T[]): T[] {
  const m = new Map<string, T>();
  for (const x of arr) m.set(x.id, x);
  return Array.from(m.values());
}

async function keywordAndVectorSearch(queries: string[]): Promise<SearchItem[]> {
  // 구현부는 기존 검색기 신호에 맞춰 연결하세요.
  // - queries 를 키워드 OR 질의로 돌리며
  // - 임베딩 기반 유사도 결과(item.vectorScore 설정)
  // - sourceType 메타데이터(regulation/education/accident)도 세팅
  return [];
}
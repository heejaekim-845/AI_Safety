핵심 원인 (코드 기준)

프로파일만 고르고 실제 쿼리는 옛 방식 유지

server/ai-service (1).ts 내부에 클래스 메서드 buildTargetedSearchQuery()(GIS/전기 하드코딩)가 남아 있습니다.

실제 검색은 profiles.ts의 빌더를 쓰지 않고, 수동으로 searchQueries를 구성 → 제조업 키워드가 섞인 벡터 Top-k가 그대로 유입.

resolveProfile 에 workType 미전달

현재: resolveProfile(equipmentInfoObj)

권장: resolveProfile(equipmentInfoObj, workType)

프로파일에 work_types_any 조건이 있으면 매칭 실패 → default로 폴백.

초기 후보군에 산업/설비 필터가 없음

chromaDBService.searchRelevantData(query, 15) 호출에서 메타데이터 필터(where) 미사용.

후단 필터도 법규/교육 중심이고, 사고사례는 블록리스트만 적용 → “사출/소각/성형기/컨베이어…”가 남음.

스코어러가 산업 불일치 패널티를 주지 않음

applyHybridScoring()은 교육자료에만 shouldIncludeContent()를 적용.

사고사례/기타에도 프로파일 기반 관련성 + 산업 불일치 패널티가 필요.

프로파일 로딩 폴백 가능성

profiles.ts가 config/search-profiles.json 로드를 실패하면 기본(default)로 폴백.

로그에 [프로파일 폴백]이 보이면 경로/문법 문제.

바로 적용할 최소 수정 패치
A. 프로파일 매칭에 workType 전달
- const resolvedProfile = resolveProfile(equipmentInfoObj);
+ const resolvedProfile = resolveProfile(equipmentInfoObj, workType);

B. 쿼리 빌드: 프로파일 빌더로 전면 교체 + 반(反)키워드 주입
import { buildTargetedSearchQuery } from './profiles.js';

- // (과거) 수동 searchQueries 조립 블록
- let searchQueries: string[] = [];
- ... 전기/GIS 하드코딩 쿼리 push ...

+ // (신규) 프로파일 기반 쿼리 일원화
+ const { accidents, regulation, education, all } =
+   buildTargetedSearchQuery(resolvedProfile, equipmentInfoObj, workType);
+
+ // 프로파일의 제외 키워드 + 제조업 잡음 차단용 기본 반키워드
+ const negatives = (resolvedProfile.exclude_if_any_keywords ?? [])
+   .concat(['사출','성형기','소각','컨베이어','벨트','제조','생산라인','가공']);
+
+ // 키워드 검색계(DF/TF)에는 NOT 적용, 벡터계엔 문자열만(하단 필터/패널티로 보정)
+ const searchQueries = all.map(q =>
+   negatives.reduce((s, n) => `${s} -${n}`, q)
+ );


중요: 클래스 내부의 옛 private buildTargetedSearchQuery(...)는 혼동을 막기 위해 삭제하거나 이름을 바꿔주세요(전역 import와 그림자 충돌 방지).

C. 벡터 검색 단계에 ‘산업/설비’ where 필터(가능 시) + 사후 필터

가능하면 chromaDBService.searchRelevantData가 where를 받도록 확장:

// 예: Chroma
const where = { industry: { "$in": ["electrical","substation","gis"] } };
const queryResults = await chromaDBService.searchRelevantData(query, 15, { where });


메타 필터를 못 쓰는 경우엔 사후 필터 + 근접 보정(거리 기준 유예):

const industryTags = new Set(['electrical','substation','gis']);
const isIndustryMatch = (m: any) => {
  const tags = (m?.tags || []).map((t: string) => t.toLowerCase());
  const ind  = (m?.industry || '').toLowerCase();
  return tags.some((t: string) => industryTags.has(t)) || industryTags.has(ind);
};

// too-close(아주 유사)한 건은 살리고, 나머지는 산업불일치 컷
filteredChromaResults = filteredChromaResults.filter(r =>
  isIndustryMatch(r.metadata) || r.distance < 0.15  // distance가 낮을수록 유사
);

D. 사고사례에도 프로파일 관련성 필터 적용
- const preFilteredAccidents = filteredChromaResults.filter(r => {
+ const preFilteredAccidents = filteredChromaResults.filter(r => {
    if (r.metadata.type !== 'incident') return false;

+   // 프로파일 기반 관련성 필터 (교육자료뿐 아니라 사고에도)
+   const searchItem: SearchItem = {
+     content: `${r.metadata?.title || ''}\n${r.document || ''}`,
+     title: r.metadata?.title,
+     metadata: r.metadata
+   };
+   if (!shouldIncludeContent(searchItem, resolvedProfile)) return false;

    if (resolvedProfile.id === 'electrical-hv-gis') {
      const t = (r.metadata?.title || '').toLowerCase();
      const c = (r.document || '').toLowerCase();
      const ban = ['사출','성형기','소각','컨베이어','벨트','제조','생산라인','가공'];
      if (ban.some(b => t.includes(b) || c.includes(b))) return false;
    }
    return true;
});

E. 하이브리드 스코어링에 산업 불일치 패널티 추가

server/ai-service (1).ts 의 private applyHybridScoring(...) 내:

      // --- 기존 hybridScore 계산 직후 ---
+     // 산업/설비 불일치 패널티
+     const tags = (result.metadata?.tags || []).map((x: string) => x.toLowerCase());
+     const industry = (result.metadata?.industry || '').toLowerCase();
+     const expect = new Set(['electrical','substation','gis']);
+     const industryOk = tags.some((t: string) => expect.has(t)) || expect.has(industry);
+     if (!industryOk) {
+       // 교육은 완전 제외보단 패널티, 사고/법규는 더 강하게
+       const penalty = isEducation ? 0.15 : 0.3;
+       hybridScore = Math.max(0, hybridScore - penalty);
+     }

F. 프로파일 로딩/매칭 가시화 (오동작 조기 발견)

profiles.ts

- if (cachedProfiles) return cachedProfiles;
+ if (cachedProfiles) {
+   console.log(`[profiles] cached: ${cachedProfiles.length} loaded`);
+   return cachedProfiles;
+ }
...
- console.error('프로파일 로딩 실패, 기본 프로파일 사용:', error);
+ console.error('[profiles] 로딩 실패 → default 사용:', error);


resolveProfile(...) 앞뒤 로그는 이미 잘 찍고 계십니다. 여기에 선택 사유도 추가하면 매칭 실패 원인이 금방 보입니다.

console.log(`[profiles] try match with name="${name}", tags=[${[...tags]}], work="${work}", risks=[${[...riskTa
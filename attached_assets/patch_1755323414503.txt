This patch set is designed to fix the “no results for regulation/education/incidents” issue by (1) separating vector vs keyword queries, (2) relaxing upstream filters, (3) normalizing content types, (4) gating penalties correctly, (5) adding dynamic thresholds with fallbacks, and (6) instrumenting each stage with counters.

Copy the blocks into server/ai-service.ts (your latest ai-service (3).ts). If your file name differs, adapt accordingly. Where noted “PLACE INSIDE YOUR SEARCH FLOW,” insert at the point you currently build queries, call search, filter, score, and threshold.

1) Add helpers (top of file, after imports)

// ---------- Diagnostics ----------
function dbgCount<T>(label: string, list: T[]) {
  const n = Array.isArray(list) ? list.length : 0;
  console.log(`[dbg] ${label}:`, n);
  return list;
}

// ---------- Type normalization ----------
function normType(m: any) {
  const s = (m?.type || m?.sourceType || '').toLowerCase();
  if (s === 'accident') return 'incident';
  return s;
}

// ---------- Negatives for keyword-only queries ----------
function applyNegatives(query: string, negatives: string[]): string {
  return negatives.reduce((s, n) => `${s} -${n}`, query);
}

// ---------- Upstream where (relaxed) ----------
function buildRelaxedWhere(expectedTags: string[] | undefined) {
  const tags = (expectedTags || []).filter(Boolean);
  if (!tags.length) return undefined; // no upstream filter when none
  return {
    $or: [
      { tags: { $containsAny: tags } },
      { tags: { $exists: false } },
      { industry: { $exists: false } }
    ]
  };
}

// ---------- Dedup ----------
function dedupById<T extends { id: string }>(arr: T[]): T[] {
  const m = new Map<string, T>();
  for (const x of arr) if (x && x.id) m.set(x.id, x);
  return Array.from(m.values());
}

// ---------- Thresholds & fallbacks ----------
function computeThreshold(scores: number[], kind: 'incident' | 'education' | 'regulation') {
  if (!scores.length) return 0;
  const sorted = [...scores].sort((a, b) => a - b);
  const idx = Math.floor(sorted.length * 0.70); // pass top 30%
  const p = sorted[idx] ?? 0;
  const cap = kind === 'education' ? 0.25 : 0.35;
  return Math.min(p, cap);
}

function applyThresholdWithFallback(list: any[], kind: 'incident' | 'education' | 'regulation') {
  const scores = list.map(x => x.hybridScore ?? 0);
  let th = computeThreshold(scores, kind);
  let out = list.filter(x => (x.hybridScore ?? 0) >= th);
  if (out.length === 0) out = list.filter(x => (x.hybridScore ?? 0) >= 0);
  if (out.length === 0 && list.length) out = list.sort((a,b)=>(b.hybridScore??0)-(a.hybridScore??0)).slice(0, Math.min(5, list.length));
  return out;
}

// ---------- Penalty wrapper over hybrid scoring ----------
import type { Profile, EquipmentInfo, WorkType, SearchItem } from './profiles';
import { applyHybridScoring, shouldIncludeContent } from './profiles';

function applyHybridScoringWithPenalty(
  list: any[],
  resolvedProfile: Profile,
  equipmentInfoObj: EquipmentInfo,
  workType?: WorkType,
  isEducation = false
) {
  const expected = new Set(
    (resolvedProfile.match?.tags_any ?? (equipmentInfoObj.tags ?? [])).map((t: string) => t.toLowerCase())
  );
  return list.map((r) => {
    const base = applyHybridScoring({
      id: r.id,
      title: r.metadata?.title,
      text: r.document,
      content: r.document,
      metadata: r.metadata,
      vectorScore: r.vectorScore ?? r.score ?? r.similarity
    } as SearchItem, resolvedProfile, equipmentInfoObj, workType);

    const tags = (r.metadata?.tags || []).map((x: string) => x.toLowerCase());
    const industry = (r.metadata?.industry || '').toLowerCase();
    const expectEmpty = expected.size === 0;
    const ok = expectEmpty || tags.some((t) => expected.has(t)) || expected.has(industry);
    const penalty = ok ? 0 : (isEducation ? 0.15 : 0.30);
    return { ...r, hybridScore: Math.max(0, base - penalty) };
  });
}

// ---------- Non-empty safeguard ----------
function ensureNonEmpty<T>(label: string, arr: T[], fallback: () => T[]): T[] {
  if (arr.length > 0) return arr;
  console.warn(`[warn] ${label} empty → fallback`);
  return fallback();
}

2) Build queries (PLACE INSIDE YOUR SEARCH FLOW)

import { resolveProfile, buildTargetedSearchQuery } from './profiles';

// Assume you already have: equipmentInfoObj, workType
const resolvedProfile = resolveProfile(equipmentInfoObj, workType);
console.log('[profiles] match', {
  id: resolvedProfile.id,
  name: equipmentInfoObj?.name,
  tags: equipmentInfoObj?.tags,
  workType: workType?.name
});

const { accidents, regulation, education, all } =
  buildTargetedSearchQuery(resolvedProfile, equipmentInfoObj, workType);

dbgCount('queries.all', all);

// negatives ONLY for keyword queries
const negatives = (resolvedProfile.exclude_if_any_keywords ?? [])
  .concat(['사출', '성형기', '소각', '컨베이어', '벨트', '제조', '생산라인', '가공']);

const queriesForVector = all; // NO negatives
const queriesForKeyword = all.map(q => applyNegatives(q, negatives));

const expectedTags = resolvedProfile.match?.tags_any ?? (equipmentInfoObj.tags ?? []);
const where = buildRelaxedWhere(expectedTags);

3) Run searches (vector + keyword) and combine (PLACE INSIDE YOUR SEARCH FLOW)

// Wire these to your actual search functions
// Example adapters — replace the bodies to call your engines
async function runVectorQueries(queries: string[], where?: any): Promise<any[]> {
  const out: any[] = [];
  for (const q of queries) {
    try {
      // Replace with your real call, e.g. chromaDBService.searchRelevantData(q, 15, { where })
      const res = await chromaDBService.searchRelevantData(q, 15, where ? { where } : undefined);
      out.push(...(Array.isArray(res) ? res : []));
    } catch (e) {
      console.warn('[vec] query failed', q, e);
    }
  }
  return out;
}

async function runKeywordQueries(queries: string[]): Promise<any[]> {
  const out: any[] = [];
  for (const q of queries) {
    try {
      // Replace with your real call, e.g. fullTextService.search(q, 15)
      const res = await keywordSearchService.search(q, 15);
      out.push(...(Array.isArray(res) ? res : []));
    } catch (e) {
      console.warn('[kw] query failed', q, e);
    }
  }
  return out;
}

const vecCandidates = await runVectorQueries(queriesForVector, where);
const kwCandidates  = await runKeywordQueries(queriesForKeyword);

const candidatesRaw = dbgCount('candidates.raw', dedupById([...(vecCandidates || []), ...(kwCandidates || [])]));

4) Prefilter by type + profile (PLACE INSIDE YOUR SEARCH FLOW)

const preIncidents = dbgCount('incidents.prefilter', (candidatesRaw || []).filter(r => {
  return normType(r.metadata) === 'incident' && shouldIncludeContent({
    id: r.id,
    title: r.metadata?.title,
    text: r.document,
    content: r.document,
    metadata: r.metadata
  }, resolvedProfile);
}));

const preEducation = dbgCount('education.prefilter', (candidatesRaw || []).filter(r => {
  return normType(r.metadata) === 'education' && shouldIncludeContent({
    id: r.id,
    title: r.metadata?.title,
    text: r.document,
    content: r.document,
    metadata: r.metadata
  }, resolvedProfile);
}));

const preRegulations = dbgCount('regulations.prefilter', (candidatesRaw || []).filter(r => {
  return normType(r.metadata) === 'regulation' && shouldIncludeContent({
    id: r.id,
    title: r.metadata?.title,
    text: r.document,
    content: r.document,
    metadata: r.metadata
  }, resolvedProfile);
}));

5) Score + penalty + thresholds + fallbacks (PLACE INSIDE YOUR SEARCH FLOW)

const scoredIncidents = dbgCount('incidents.scored', applyHybridScoringWithPenalty(
  preIncidents, resolvedProfile, equipmentInfoObj, workType, /*isEducation*/ false
));
const scoredEducation = dbgCount('education.scored', applyHybridScoringWithPenalty(
  preEducation, resolvedProfile, equipmentInfoObj, workType, /*isEducation*/ true
));
const scoredRegulations = dbgCount('regulations.scored', applyHybridScoringWithPenalty(
  preRegulations, resolvedProfile, equipmentInfoObj, workType, /*isEducation*/ false
));

const finalIncidents   = dbgCount('incidents.post-threshold', applyThresholdWithFallback(scoredIncidents, 'incident'));
const finalEducation   = dbgCount('education.post-threshold', applyThresholdWithFallback(scoredEducation, 'education'));
const finalRegulations = dbgCount('regulations.post-threshold', applyThresholdWithFallback(scoredRegulations, 'regulation'));

// Safety: guarantee some output if everything is empty
const incidentsOut   = ensureNonEmpty('incidents', finalIncidents, () => scoredIncidents.slice(0, Math.min(5, scoredIncidents.length)));
const educationOut   = ensureNonEmpty('education', finalEducation, () => scoredEducation.slice(0, Math.min(5, scoredEducation.length)));
const regulationsOut = ensureNonEmpty('regulations', finalRegulations, () => scoredRegulations.slice(0, Math.min(5, scoredRegulations.length)));

6) Metadata defaults (fix any earlier hard-coded values)

// When building SearchItem metadata for known data, DO NOT hardcode defaults like "전기작업" or "제조업".
const itemMeta = {
  work_type: metadata.work_type || (workType?.name ?? '일반작업'),
  industry:  metadata.industry  || ((resolvedProfile.match?.tags_any ?? [])[0] ?? '미상'),
  risk_keywords: metadata.risk_keywords || (Array.isArray(equipmentInfoObj?.riskTags) ? equipmentInfoObj.riskTags.join(', ') : undefined),
  ...metadata
};

7) Vector vs Keyword query usage (final reminder)

Vector: queriesForVector (no negatives), { where: buildRelaxedWhere(...) }

Keyword: queriesForKeyword (with negatives)